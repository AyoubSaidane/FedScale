variable                            type                        life cycle ("/" = per)

self.model = None                   object                      write at init, read and write / round completion
self.model_in_update = 0            int                         

self.executors = None               list[int]                   write at init, read at registration / test completion

self.sampled_participants = []      list[int]                   write all and read / round completion
self.sampled_executors = []         list[str]                   read / event, write all / round completion

self.round_stragglers = []          list[int]                   write all and read / round completion
self.model_update_size = 0.         float                       write at init, read at registration and / round completion

self.collate_fn = None              object                      not used
self.task = args.task               str                         not used
self.round = 0                      int                         

self.start_run_time = time.time()   float                       not used
self.client_conf = {}               dict                        never write?

self.stats_util_accumulator = []    list[float]                 write append / client completion, read and clear / round completion
self.loss_accumulator = []          list[float]                 write append / client completion
self.client_training_results = []   list[dict]                  write append / client completion, clear / round completion
self.test_result_accumulator = []   list[dict]                  write append and read / test completion, read / round completion

event queues?                       deque[tuple]


self.model = None                   object                      write at init, read and write / round completion                   

self.executors = None               list[int]                   write at init, read at registration and / test completion *

self.sampled_participants = []      list[int]                   write all and read / round completion *
self.sampled_executors = []         list[str]                   read / event, write all / round completion *

self.round_stragglers = []          list[int]                   write all and read / round completion *

self.stats_util_accumulator = []    list[float]                 write append / client completion, read and clear / round completion *
self.loss_accumulator = []          list[float]                 write append / client completion *
self.client_training_results = []   list[dict]                  write append / client completion, clear / round completion *
self.test_result_accumulator = []   list[dict]                  write append and read / test completion, read / round completion *